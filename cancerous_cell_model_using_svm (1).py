# -*- coding: utf-8 -*-
"""cancerous cell model using svm

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SJyjV1DilLLtTtq7bdJL3prpoqlcCoe-
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import pylab as pl
import scipy.optimize as opt
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
# %matplotlib inline
import matplotlib.pyplot as plt
import seaborn as sns

from google.colab import drive
drive.mount('/content/drive')

cell_df = pd.read_csv('Cancer_Data.csv')
cell_df.head()
print(cell_df.columns)

# Load the dataset and analyize
file_path = 'Cancer_Data.csv'  # Make sure to replace this with the actual file path
data = pd.read_csv(file_path)

# Remove the unnecessary column
data_clean = data.drop(['Unnamed: 32', 'id'], axis=1)

# Set up the plot for radius_mean comparison
plt.figure(figsize=(10,6))
sns.histplot(data=data_clean, x='radius_mean', hue='diagnosis', element='step', stat='density', common_norm=False, palette={'M':'red', 'B':'blue'})

# Add plot details
plt.title('Distribution of Radius Mean by Diagnosis', fontsize=16)
plt.xlabel('Radius Mean', fontsize=14)
plt.ylabel('Density', fontsize=14)
plt.legend(title='Diagnosis', labels=['Malignant', 'Benign'])
plt.grid(True)

# Show plot
plt.tight_layout()
plt.show()

# data processing
cell_df.dtypes

# Step 1: Distribution of Malignant vs. Benign Cases
diagnosis_counts = data_clean['diagnosis'].value_counts()

# Plot the distribution
plt.figure(figsize=(6,4))
sns.barplot(x=diagnosis_counts.index, y=diagnosis_counts.values, palette={'M':'red', 'B':'blue'})
plt.title('Distribution of Malignant vs. Benign Cases')
plt.xlabel('Diagnosis')
plt.ylabel('Count')
plt.show()

# Step 2: Pairplot of Important Features
# Selecting top features for pairplot visualization
selected_features = ['radius_mean', 'perimeter_mean', 'area_mean', 'concave points_mean', 'concave points_worst', 'diagnosis']

# Create a pairplot to visualize the relationship between important features
sns.pairplot(data_clean[selected_features], hue='diagnosis', palette={'M':'red', 'B':'blue'})

plt.show()

# setting of independent and dependent variables x and y
feautures = [
    'concave points_worst','perimeter_worst','concave points_mean','radius_worst','perimeter_mean',
    'area_worst','radius_mean','area_mean','concavity_mean','concavity_worst'
]

x = np.asarray(feautures)
x[0:5]

can = cell_df['diagnosis']
y = np.asarray(can)
y[0:5]


print(x[0:5])
print(y[0:5])

# train,test dataset
from sklearn.model_selection import train_test_split

# Define the feature matrix (X) and target vector (y)
X = data_clean[feautures]  # clean the array of top 10 features
y = data_clean['diagnosis']    # clean Target variable (diagnosis)

# Split the data into training and testing sets
x_train, x_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=4)

# Print the shape of the train and test sets
print('Train set: ', x_train.shape, y_train.shape)
print('Test set: ', x_test.shape, y_test.shape)

# modeling(svm)
from sklearn import svm
clf  = svm.SVC(kernel='linear') #you can change the value of the kernel to other optioons like poly,sigmoid,and rbf to suit your models accuracy
clf.fit(x_train,y_train)
yhat=clf.predict(x_test)
yhat[0:5]

from sklearn.metrics import jaccard_score

# Use pos_label='M' for malignant
jaccard = jaccard_score(y_test, yhat, pos_label='M')
print("Jaccard Score: ", jaccard)

# to predict you can pass your own values
# Function to predict diagnosis based on user input
def predict_diagnosis(features):

    input_data = np.array(features).reshape(1, -1)

    # Make prediction
    prediction = clf.predict(input_data)

    return prediction[0]

# Example usage
if __name__ == "__main__":
    print("Enter the values for the following features:")
    radius_mean = float(input("radius_mean: "))
    perimeter_mean = float(input("perimeter_mean: "))
    area_mean = float(input("area_mean: "))
    concave_points_mean = float(input("concave points_mean: "))
    concave_points_worst = float(input("concave points_worst: "))
    perimeter_worst = float(input("perimeter_worst: "))
    radius_worst = float(input("radius_worst: "))
    area_worst = float(input("area_worst: "))
    concavity_mean = float(input("concavity_mean: "))
    concavity_worst = float(input("concavity_worst: "))

    # Prepare features for prediction
    user_features = [
        concave_points_worst,
        perimeter_worst,
        concave_points_mean,
        radius_worst,
        perimeter_mean,
        area_worst,
        radius_mean,
        area_mean,
        concavity_mean,
        concavity_worst
    ]

    # Predict and print result
    result = predict_diagnosis(user_features)
    print(f"The predicted diagnosis is: {result}")